import React, {
// JSXElementConstructor,
// Component,
useContext, useEffect, useMemo, useRef, useState } from 'react';
import { deepMerge,
// deepMergeArray,
getResolvedTokenValueFromConfig, deepMergeObjects, resolveStringToken } from './utils';
import { convertUtilityPropsToSX } from './core/convert-utility-to-sx';
import { useStyled } from './StyledProvider';
import { propertyTokenMap } from './propertyTokenMap';
import { Platform, useWindowDimensions, StyleSheet } from 'react-native';
import { injectInStyle } from './injectInStyle';
import { INTERNAL_updateCSSStyleInOrderedResolved } from './updateCSSStyleInOrderedResolved';
import { generateStylePropsFromCSSIds } from './generateStylePropsFromCSSIds';
import { get, onChange } from './core/colorMode';
import { styledResolvedToOrderedSXResolved, styledToStyledResolved, getStyleIds, getComponentResolvedBaseStyle, getComponentResolvedVariantStyle, getDescendantResolvedBaseStyle, getDescendantResolvedVariantStyle } from './resolver';
import { convertStyledToStyledVerbosed, convertSxToSxVerbosed } from './convertSxToSxVerbosed';
import { stableHash } from './stableHash';
function convertUtiltiyToSXFromProps(componentProps, componentExtendedConfig, componentStyleConfig) {
  const {
    sx: userSX,
    verboseSx: verboseSx,
    ...componentRestProps
  } = {
    ...componentProps
  };
  const resolvedSXVerbosed = convertSxToSxVerbosed(userSX);
  const {
    sxProps: utilityResolvedSX,
    mergedProps: restProps
  } = convertUtilityPropsToSX(componentExtendedConfig, componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.descendantStyle, componentRestProps);
  const resolvedSxVerbose = deepMerge(utilityResolvedSX, resolvedSXVerbosed);
  const sx = deepMerge(resolvedSxVerbose, verboseSx);
  return {
    sx,
    rest: restProps
  };
}
function getStateStyleCSSFromStyleIdsAndProps(styleIdObject, states, colorMode) {
  const stateStyleCSSIds = [];
  let props = {};
  if (colorMode || states && typeof states !== 'undefined') {
    function isSubset(subset, set) {
      return subset.every(item => set.includes(item));
    }
    function flattenObject(obj) {
      const flat = {};

      // Recursive function to flatten the object
      function flatten(obj) {
        let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        // Iterate over the object's keys

        if (Array.isArray(obj)) {
          flat[`${path.join('.')}`] = obj;
        } else {
          for (const key of Object.keys(obj)) {
            // If the value is an object, recurse
            if (key === 'ids' && path.length > 0) {
              flat[`${path.join('.')}`] = obj[key];
            } else if (key === 'props') {
              flat[`${path.join('.')}.${key}`] = obj[key];
            } else if (typeof obj[key] === 'object') {
              flatten(obj[key], [...path, key]);
            } else {
              flat[`${path.join('.')}`] = obj[key];
            }
          }
        }
      }
      flatten(obj);
      return flat;
    }
    const flatternStyleIdObject = flattenObject(styleIdObject);
    Object.keys(flatternStyleIdObject).forEach(styleId => {
      const styleIdKeyArray = styleId.split('.');
      const filteredStyleIdKeyArray = styleIdKeyArray.filter(item => item !== 'colorMode' && item !== 'state' && item !== 'props');
      const stateColorMode = {
        ...states,
        [colorMode]: true
      };
      const currentStateArray = Object.keys(stateColorMode).filter(key => stateColorMode[key] === true);
      if (styleId.includes('ids')) {
        // if (type === 'inline' && ) {
        // stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
        // }
      } else if (styleId.includes('props') && isSubset(filteredStyleIdKeyArray, currentStateArray)) {
        props = deepMergeObjects(props, flatternStyleIdObject[styleId]);
      } else {
        if (isSubset(filteredStyleIdKeyArray, currentStateArray)) {
          stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
        }
      }
    });
  }
  return {
    cssIds: stateStyleCSSIds,
    passingProps: props
  };
}
function isValidVariantCondition(condition, variants) {
  for (const key in condition) {
    if (!variants.hasOwnProperty(key) || variants[key] !== condition[key]) {
      return false;
    }
  }
  return true;
}
function getMergedDefaultCSSIdsAndProps(componentStyleIds, incomingVariantProps, theme, properties) {
  var _componentStyleIds$ba;
  let props = {};
  const baseStyleCSSIds = [];
  const variantStyleCSSIds = [];
  if (componentStyleIds && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.baseStyle && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$ba = componentStyleIds.baseStyle) !== null && _componentStyleIds$ba !== void 0 && _componentStyleIds$ba.ids) {
    var _componentStyleIds$ba2, _componentStyleIds$ba3;
    baseStyleCSSIds.push(...(componentStyleIds === null || componentStyleIds === void 0 ? void 0 : (_componentStyleIds$ba2 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba2 === void 0 ? void 0 : _componentStyleIds$ba2.ids));
    props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 ? void 0 : (_componentStyleIds$ba3 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba3 === void 0 ? void 0 : _componentStyleIds$ba3.props);
  }
  let passingVariantProps = getVariantProps(props, theme).variantProps;
  const mergedVariantProps = {
    ...passingVariantProps,
    ...incomingVariantProps
  };
  Object.keys(mergedVariantProps).forEach(variant => {
    var _componentStyleIds$va, _componentStyleIds$va2, _componentStyleIds$va3;
    const variantName = mergedVariantProps[variant];
    if (variant && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants[variant] && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va !== void 0 && _componentStyleIds$va[variantName] && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va2 = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va2 !== void 0 && (_componentStyleIds$va3 = _componentStyleIds$va2[variantName]) !== null && _componentStyleIds$va3 !== void 0 && _componentStyleIds$va3.ids) {
      var _componentStyleIds$va4, _componentStyleIds$va5, _componentStyleIds$va6, _componentStyleIds$va7;
      variantStyleCSSIds.push(
      //@ts-ignore
      ...(componentStyleIds === null || componentStyleIds === void 0 ? void 0 : (_componentStyleIds$va4 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va4 === void 0 ? void 0 : (_componentStyleIds$va5 = _componentStyleIds$va4[variantName]) === null || _componentStyleIds$va5 === void 0 ? void 0 : _componentStyleIds$va5.ids));

      // if this variant exist in remaining props, remove it from remaining props
      if (properties[variant]) {
        delete properties[variant];
      }
      if (props[variant]) {
        delete props[variant];
      }
      props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 ? void 0 : (_componentStyleIds$va6 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va6 === void 0 ? void 0 : (_componentStyleIds$va7 = _componentStyleIds$va6[variantName]) === null || _componentStyleIds$va7 === void 0 ? void 0 : _componentStyleIds$va7.props);
    }
  });
  componentStyleIds === null || componentStyleIds === void 0 ? void 0 : componentStyleIds.compoundVariants.forEach(compoundVariant => {
    if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
      if (compoundVariant.ids) {
        variantStyleCSSIds.push(
        //@ts-ignore
        ...compoundVariant.ids);
      }
      props = deepMergeObjects(props, compoundVariant === null || compoundVariant === void 0 ? void 0 : compoundVariant.props);
    }
  });
  return {
    baseStyleCSSIds: baseStyleCSSIds,
    variantStyleCSSIds: variantStyleCSSIds,
    passingProps: props
  };
}
const getMergeDescendantsStyleCSSIdsAndPropsWithKey = (descendantStyles, variantProps, theme, properties) => {
  const descendantStyleObj = {};
  if (descendantStyles) {
    var _Object$keys;
    (_Object$keys = Object.keys(descendantStyles)) === null || _Object$keys === void 0 ? void 0 : _Object$keys.forEach(key => {
      const styleObj = descendantStyles[key];
      const {
        baseStyleCSSIds,
        variantStyleCSSIds,
        passingProps: defaultPassingProps
      } = getMergedDefaultCSSIdsAndProps(styleObj, variantProps, theme, properties);
      descendantStyleObj[key] = {
        baseStyleCSSIds: baseStyleCSSIds,
        variantStyleCSSIds: variantStyleCSSIds,
        passingProps: defaultPassingProps
      };
    });
  }
  return descendantStyleObj;
};
const Context = /*#__PURE__*/React.createContext({});
const globalStyleMap = new Map();
//

// window['globalStyleMap'] = globalStyleMap;
// const globalOrderedList: any = [];
// setTimeout(() => {
//   const orderedList = globalOrderedList.sort(
//     (a: any, b: any) => a.meta.weight - b.meta.weight
//   );
//   injectInStyle(orderedList);
// });

function getMergedStateAndColorModeCSSIdsAndProps(componentStyleIds, states, incomingVariantProps, COLOR_MODE, theme) {
  var _componentStyleIds$co;
  const stateBaseStyleCSSIds = [];
  const stateVariantStyleCSSIds = [];
  let props = {};
  if (componentStyleIds.baseStyle) {
    const {
      cssIds: stateStleCSSFromStyleIds,
      passingProps: stateStyleProps
    } = getStateStyleCSSFromStyleIdsAndProps(componentStyleIds.baseStyle, states, COLOR_MODE);
    stateBaseStyleCSSIds.push(...stateStleCSSFromStyleIds);
    props = deepMergeObjects(props, stateStyleProps);
  }
  let passingVariantProps = getVariantProps(props, theme).variantProps;
  const mergedVariantProps = {
    ...passingVariantProps,
    ...incomingVariantProps
  };
  Object.keys(mergedVariantProps).forEach(variant => {
    if (variant && componentStyleIds.variants && componentStyleIds.variants[variant] && componentStyleIds.variants[variant][mergedVariantProps[variant]]) {
      const {
        cssIds: stateStleCSSFromStyleIds,
        passingProps: stateStyleProps
      } = getStateStyleCSSFromStyleIdsAndProps(componentStyleIds.variants[variant][mergedVariantProps[variant]], states, COLOR_MODE);
      stateVariantStyleCSSIds.push(...stateStleCSSFromStyleIds);
      props = deepMergeObjects(props, stateStyleProps);
    }
  });
  componentStyleIds === null || componentStyleIds === void 0 ? void 0 : (_componentStyleIds$co = componentStyleIds.compoundVariants) === null || _componentStyleIds$co === void 0 ? void 0 : _componentStyleIds$co.forEach(compoundVariant => {
    if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
      const {
        cssIds: stateStleCSSFromStyleIds,
        passingProps: stateStyleProps
      } = getStateStyleCSSFromStyleIdsAndProps(
      //@ts-ignore
      compoundVariant, states, COLOR_MODE);
      stateVariantStyleCSSIds.push(...stateStleCSSFromStyleIds);
      props = deepMergeObjects(props, stateStyleProps);
    }
  });
  return {
    baseStyleCSSIds: stateBaseStyleCSSIds,
    variantStyleCSSIds: stateVariantStyleCSSIds,
    passingProps: props
  };
}
function getAncestorCSSStyleIds(compConfig, context) {
  var _compConfig$ancestorS;
  let ancestorBaseStyleIds = [];
  let ancestorVariantStyleIds = [];
  let ancestorPassingProps = {};
  if (((_compConfig$ancestorS = compConfig.ancestorStyle) === null || _compConfig$ancestorS === void 0 ? void 0 : _compConfig$ancestorS.length) > 0) {
    compConfig.ancestorStyle.forEach(ancestor => {
      if (context[ancestor]) {
        var _context$ancestor, _context$ancestor2, _context$ancestor3;
        ancestorBaseStyleIds = (_context$ancestor = context[ancestor]) === null || _context$ancestor === void 0 ? void 0 : _context$ancestor.baseStyleCSSIds;
        ancestorVariantStyleIds = (_context$ancestor2 = context[ancestor]) === null || _context$ancestor2 === void 0 ? void 0 : _context$ancestor2.variantStyleCSSIds;
        ancestorPassingProps = (_context$ancestor3 = context[ancestor]) === null || _context$ancestor3 === void 0 ? void 0 : _context$ancestor3.passingProps;
      }
    });
  }
  return {
    baseStyleCSSIds: ancestorBaseStyleIds,
    variantStyleIds: ancestorVariantStyleIds,
    passingProps: ancestorPassingProps
  };
}
function mergeArraysInObjects() {
  const merged = {};
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  for (const object of objects) {
    Object.keys(object).forEach(key => {
      const value = object[key];
      if (!merged[key]) {
        merged[key] = {
          baseStyleCSSIds: [],
          variantStyleCSSIds: [],
          passingProps: {}
        };
      }
      merged[key].baseStyleCSSIds.push(...value.baseStyleCSSIds);
      merged[key].variantStyleCSSIds.push(...value.variantStyleCSSIds);
      merged[key].passingProps = deepMergeObjects(merged[key].passingProps, value.passingProps);
    });
  }
  return merged;
}

// let resolvedComponentMap = new Map<Component, any>();

// function isAlreadyResolved(Component) {

// }
function resolvePlatformTheme(theme, platform) {
  if (typeof theme === 'object') {
    Object.keys(theme).forEach(themeKey => {
      if (themeKey !== 'style' && themeKey !== 'defaultProps') {
        if (theme[themeKey].platform) {
          let temp = {
            ...theme[themeKey]
          };
          theme[themeKey] = deepMerge(temp, theme[themeKey].platform[platform]);
          delete theme[themeKey].platform;
          resolvePlatformTheme(theme[themeKey], platform);
        } else if (themeKey === 'queries') {
          theme[themeKey].forEach(query => {
            if (query.value.platform) {
              let temp = {
                ...query.value
              };
              query.value = deepMerge(temp, query.value.platform[platform]);
              delete query.value.platform;
            }
            resolvePlatformTheme(query.value, platform);
          });
        } else {
          resolvePlatformTheme(theme[themeKey], platform);
        }
      }
    });
  }
}
export function getVariantProps(props, theme) {
  let shouldDeleteVariants = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const variantTypes = theme !== null && theme !== void 0 && theme.variants ? Object.keys(theme.variants) : [];
  const restProps = {
    ...props
  };
  const variantProps = {};
  variantTypes === null || variantTypes === void 0 ? void 0 : variantTypes.forEach(variant => {
    if (props[variant]) {
      variantProps[variant] = props[variant];
      if (shouldDeleteVariants) delete restProps[variant];
    }
  });
  return {
    variantProps,
    restProps
  };
}
export function verboseStyled(Component, theme) {
  let componentStyleConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let ExtendedConfig = arguments.length > 3 ? arguments[3] : undefined;
  let BUILD_TIME_PARAMS = arguments.length > 4 ? arguments[4] : undefined; //@ts-ignore
  let styleHashCreated = false;
  let orderedResolved;
  let componentStyleIds = {};
  let componentDescendantStyleIds = {}; // StyleIds = {};
  let componentExtendedConfig = {};
  let styleIds = {};
  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.orderedResolved) {
    orderedResolved = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.orderedResolved;
  }
  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.styleIds) {
    styleIds = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.styleIds;
  }
  resolvePlatformTheme(theme, Platform.OS);

  // const styledResolved = styledToStyledResolved(theme, [], CONFIG);
  // const orderedResovled = styledResolvedToOrderedSXResolved(styledResolved);

  // INTERNAL_updateCSSStyleInOrderedResolved(orderedResovled);
  // //set css ruleset
  // globalOrderedList.push(...orderedResovled);

  // // StyleIds
  // const componentStyleIds = getComponentStyleIds(
  //   orderedResovled.filter((item) => !item.meta.path?.includes('descendants'))
  // );

  // if (componentStyleConfig.DEBUG === 'INPUT') {
  //   // console.log(componentStyleIds, 'hello state here >>');
  // }

  // // Descendants
  // const descendantStyleIds = getDescendantStyleIds(
  //   orderedResovled.filter((item) => item.meta.path?.includes('descendants')),
  //   componentStyleConfig.descendantStyle
  // );

  //

  function injectComponentAndDescendantStyles(orderedResolved, styleTagId) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'boot';
    // const componentOrderResolved = getComponentResolved(orderedResolved);
    // const descendantOrderResolved = getDescendantResolved(orderedResolved);

    const componentOrderResolvedBaseStyle = getComponentResolvedBaseStyle(orderedResolved);
    const componentOrderResolvedVariantStyle = getComponentResolvedVariantStyle(orderedResolved);
    const descendantOrderResolvedBaseStyle = getDescendantResolvedBaseStyle(orderedResolved);
    const descendantOrderResolvedVariantStyle = getDescendantResolvedVariantStyle(orderedResolved);
    injectInStyle(globalStyleMap, componentOrderResolvedBaseStyle, type + '-base', styleTagId ? styleTagId : 'css-injected-boot-time');
    injectInStyle(globalStyleMap, descendantOrderResolvedBaseStyle, type + '-descendant-base', styleTagId ? styleTagId : 'css-injected-boot-time-descendant');
    injectInStyle(globalStyleMap, componentOrderResolvedVariantStyle, type + '-variant', styleTagId ? styleTagId : 'css-injected-boot-time');
    injectInStyle(globalStyleMap, descendantOrderResolvedVariantStyle, type + '-descendant-variant', styleTagId ? styleTagId : 'css-injected-boot-time-descendant');
  }

  // BASE COLOR MODEÂ RESOLUTION

  function setColorModeBaseStyleIds(styleIds, COLOR_MODE) {
    if (COLOR_MODE) {
      var _styleIds$baseStyle, _styleIds$baseStyle2, _styleIds$baseStyle2$;
      if (styleIds !== null && styleIds !== void 0 && (_styleIds$baseStyle = styleIds.baseStyle) !== null && _styleIds$baseStyle !== void 0 && _styleIds$baseStyle.colorMode && styleIds !== null && styleIds !== void 0 && (_styleIds$baseStyle2 = styleIds.baseStyle) !== null && _styleIds$baseStyle2 !== void 0 && (_styleIds$baseStyle2$ = _styleIds$baseStyle2.colorMode[COLOR_MODE]) !== null && _styleIds$baseStyle2$ !== void 0 && _styleIds$baseStyle2$.ids) {
        styleIds.baseStyle.ids.push(...styleIds.baseStyle.colorMode[COLOR_MODE].ids);
        styleIds.baseStyle.colorMode[COLOR_MODE].ids = [];
      }
    }
  }
  function setColorModeBaseStyleIdsDescendant(styleIds, COLOR_MODE) {
    if (COLOR_MODE) {
      Object.keys(styleIds).forEach(descendantKey => {
        var _styleIds$descendantK, _styleIds$descendantK2, _styleIds$descendantK3, _styleIds$descendantK4, _styleIds$descendantK5;
        if ((_styleIds$descendantK = styleIds[descendantKey]) !== null && _styleIds$descendantK !== void 0 && (_styleIds$descendantK2 = _styleIds$descendantK.baseStyle) !== null && _styleIds$descendantK2 !== void 0 && _styleIds$descendantK2.colorMode && (_styleIds$descendantK3 = styleIds[descendantKey]) !== null && _styleIds$descendantK3 !== void 0 && (_styleIds$descendantK4 = _styleIds$descendantK3.baseStyle) !== null && _styleIds$descendantK4 !== void 0 && (_styleIds$descendantK5 = _styleIds$descendantK4.colorMode[COLOR_MODE]) !== null && _styleIds$descendantK5 !== void 0 && _styleIds$descendantK5.ids) {
          styleIds[descendantKey].baseStyle.ids.push(...styleIds[descendantKey].baseStyle.colorMode[COLOR_MODE].ids);
          styleIds[descendantKey].baseStyle.colorMode[COLOR_MODE].ids = [];
        }
      });
    }
  }
  function injectSx(sx) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'inline';
    const inlineSxTheme = {
      baseStyle: sx
    };
    resolvePlatformTheme(inlineSxTheme, Platform.OS);
    const sxStyledResolved = styledToStyledResolved(
    // @ts-ignore
    inlineSxTheme, [], componentExtendedConfig);
    const sxHash = stableHash(sx);
    const orderedSXResolved = styledResolvedToOrderedSXResolved(sxStyledResolved);
    INTERNAL_updateCSSStyleInOrderedResolved(orderedSXResolved, sxHash, false, 'gs');
    injectComponentAndDescendantStyles(orderedSXResolved, sxHash, type);
    return orderedSXResolved;
  }

  // END BASE COLOR MODE RESOLUTION

  const NewComp = (_ref, ref) => {
    var _theme, _theme$baseStyle, _componentStyleConfig;
    let {
      as,
      ...componentProps
    } = _ref;
    const styledContext = useStyled();
    const globalStyle = styledContext.globalStyle;
    if (globalStyle) {
      resolvePlatformTheme(globalStyle, Platform.OS);
      theme = {
        ...theme,
        baseStyle: {
          ...(globalStyle === null || globalStyle === void 0 ? void 0 : globalStyle.baseStyle),
          ...theme.baseStyle
        },
        //@ts-ignore
        compoundVariants: [...(globalStyle === null || globalStyle === void 0 ? void 0 : globalStyle.compoundVariants),
        //@ts-ignore
        ...theme.compoundVariants],
        variants: {
          ...(globalStyle === null || globalStyle === void 0 ? void 0 : globalStyle.variants),
          ...theme.variants
        }
      };
    }
    const CONFIG = useMemo(() => ({
      ...styledContext.config,
      propertyTokenMap
    }), [styledContext.config]);
    const [COLOR_MODE, setCOLOR_MODE] = useState(get());
    useEffect(() => {
      onChange(colorMode => {
        setCOLOR_MODE(colorMode);
      });
    }, []);
    if (!styleHashCreated) {
      const themeHash = (BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.themeHash) || stableHash({
        ...theme,
        ...componentStyleConfig
      });

      // TODO: can be imoroved to boost performance
      componentExtendedConfig = CONFIG;
      if (ExtendedConfig) {
        componentExtendedConfig = deepMerge(CONFIG, ExtendedConfig);
      }
      if (!orderedResolved) {
        const styledResolved = styledToStyledResolved(theme, [], componentExtendedConfig);
        orderedResolved = styledResolvedToOrderedSXResolved(styledResolved);
        INTERNAL_updateCSSStyleInOrderedResolved(orderedResolved, themeHash);
      }
      if (Object.keys(styleIds).length === 0) {
        styleIds = getStyleIds(orderedResolved, componentStyleConfig);
      }
      componentStyleIds = styleIds.component;
      componentDescendantStyleIds = styleIds.descendant;
      setColorModeBaseStyleIds(componentStyleIds, COLOR_MODE);
      setColorModeBaseStyleIdsDescendant(componentDescendantStyleIds, COLOR_MODE);

      /* Boot time */

      injectComponentAndDescendantStyles(orderedResolved, themeHash);
      styleHashCreated = true;
      /* Boot time */
    }

    const contextValue = useContext(Context);
    const {
      passingProps: applyAncestorPassingProps,
      baseStyleCSSIds: applyAncestorBaseStyleCSSIds,
      variantStyleIds: applyAncestorVariantStyleCSSIds
    } = React.useMemo(() => {
      return getAncestorCSSStyleIds(componentStyleConfig, contextValue);
    }, [contextValue]);
    const incomingComponentProps = useMemo(() => {
      return {
        ...applyAncestorPassingProps,
        // As applyAncestorPassingProps is incoming props for the descendant component
        ...componentProps
      };
    }, [componentProps, applyAncestorPassingProps]);
    const {
      variantProps
    } = getVariantProps({
      //@ts-ignore
      ...((_theme = theme) === null || _theme === void 0 ? void 0 : (_theme$baseStyle = _theme.baseStyle) === null || _theme$baseStyle === void 0 ? void 0 : _theme$baseStyle.props),
      ...applyAncestorPassingProps,
      ...componentProps
    }, theme);
    const sxComponentStyleIds = useRef({});
    const sxDescendantStyleIds = useRef({});
    const sxComponentPassingProps = useRef({});

    // const applySxStyleCSSIds = useRef([]);
    const applySxBaseStyleCSSIds = useRef([]);
    const applySxVariantStyleCSSIds = useRef([]);
    const applySxDescendantStyleCSSIdsAndPropsWithKey = useRef({});

    // const [applySxStateStyleCSSIds, setApplyStateSxStyleCSSIds] = useState([]);
    const [applySxStateBaseStyleCSSIds, setApplyStateSxBaseStyleCSSIds] = useState([]);
    const [applySxStateVariantStyleCSSIds, setApplyStateSxVariantStyleCSSIds] = useState([]);
    const [applySxDescendantStateStyleCSSIdsAndPropsWithKey, setApplySxDescendantStateStyleCSSIdsAndPropsWithKey] = useState({});
    const [componentStatePassingProps, setComponentStatePassingProps] = useState({});
    const [sxStatePassingProps, setSxStatePassingProps] = useState({});
    const {
      baseStyleCSSIds: applyBaseStyleCSSIds,
      variantStyleCSSIds: applyVariantStyleCSSIds,
      passingProps: applyComponentPassingProps
    } = React.useMemo(() => {
      return getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      componentStyleIds, variantProps, theme, incomingComponentProps);
    }, [variantProps, incomingComponentProps]);
    //
    //
    //

    //
    // passingProps is specific to current component
    const passingProps = React.useMemo(() => {
      return deepMergeObjects(applyComponentPassingProps, componentStatePassingProps, sxComponentPassingProps.current, sxStatePassingProps);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [applyComponentPassingProps, sxComponentPassingProps, sxStatePassingProps, componentStatePassingProps]);
    const {
      sx: filteredComponentSx,
      rest: filteredComponentRemainingProps
    } = convertUtiltiyToSXFromProps(componentProps, componentExtendedConfig, componentStyleConfig);
    const {
      sx: filteredPassingSx,
      rest: filteredPassingRemainingProps
    } = convertUtiltiyToSXFromProps({
      ...passingProps,
      ...applyAncestorPassingProps
    }, componentExtendedConfig, componentStyleConfig);

    // if (componentStyleConfig.DEBUG === 'MYTEXT') {
    //   console.log(
    //     filteredComponentSx,
    //     filteredPassingSx,
    //     // applyAncestorPassingProps,
    //     // applyAncestorBaseStyleCSSIds,
    //     // applyAncestorVariantStyleCSSIds,
    //     componentProps,
    //     '>>>>>'
    //   );
    // }

    const remainingComponentProps = {
      ...filteredPassingRemainingProps,
      ...filteredComponentRemainingProps
    };
    const mergedWithUtilityPropsAndPassingProps = {
      ...passingProps,
      ...applyAncestorPassingProps,
      ...componentProps
    };
    const {
      children,
      states,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      sx: _sx,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      verboseSx: _versbosedSx,
      ...utilityAndPassingProps
    } = mergedWithUtilityPropsAndPassingProps;

    // Inline prop based style resolution
    const resolvedInlineProps = {};
    if (componentStyleConfig.resolveProps && Object.keys(componentExtendedConfig).length > 0) {
      componentStyleConfig.resolveProps.forEach(toBeResovledProp => {
        if (utilityAndPassingProps[toBeResovledProp]) {
          let value = utilityAndPassingProps[toBeResovledProp];
          if (CONFIG.propertyResolver && CONFIG.propertyResolver.props && CONFIG.propertyResolver.props[toBeResovledProp]) {
            let transformer = CONFIG.propertyResolver.props[toBeResovledProp];
            let aliasTokenType = CONFIG.propertyTokenMap[toBeResovledProp];
            let token = transformer(value, function (value1) {
              let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : aliasTokenType;
              return resolveStringToken(value1, CONFIG, CONFIG.propertyTokenMap, toBeResovledProp, scale);
            });
            //@ts-ignore
            resolvedInlineProps[toBeResovledProp] = token;
          } else {
            //@ts-ignore
            resolvedInlineProps[toBeResovledProp] = getResolvedTokenValueFromConfig(componentExtendedConfig, utilityAndPassingProps, toBeResovledProp, utilityAndPassingProps[toBeResovledProp]);
          }
          delete utilityAndPassingProps[toBeResovledProp];
        }
      });
    }

    // const { sx, remainingComponentProps } = filterSx(mergedSx, mergedVerboseSx);
    // TODO: filter for inline props like variant and sizes

    const [applyComponentStateBaseStyleIds, setApplyComponentStateBaseStyleIds] = useState([]);
    const [applyComponentStateVariantStyleIds, setApplyComponentStateVariantStyleIds] = useState([]);
    const applyDescendantsStyleCSSIdsAndPropsWithKey = React.useMemo(() => {
      return getMergeDescendantsStyleCSSIdsAndPropsWithKey(componentDescendantStyleIds, variantProps, theme, incomingComponentProps);
    }, [variantProps, incomingComponentProps]);
    const [applyDescendantStateStyleCSSIdsAndPropsWithKey, setApplyDescendantStateStyleCSSIdsAndPropsWithKey] = useState({});

    // ancestorCSSStyleId

    // const [applySxStyleCSSIds, setApplySxStyleCSSIds] = useState([]);

    // SX resolution

    // const styleTagId = useRef(`style-tag-sx-${stableHash(sx)}`);

    // FOR SX RESOLUTION

    if (Object.keys(filteredComponentSx).length > 0 || Object.keys(filteredPassingSx).length > 0) {
      const orderedComponentSXResolved = injectSx(filteredComponentSx, 'inline');
      const orderedPassingSXResolved = injectSx(filteredPassingSx, 'passing');
      const orderedSXResolved = [...orderedPassingSXResolved, ...orderedComponentSXResolved];
      const sxStyleIds = getStyleIds(orderedSXResolved, componentStyleConfig);

      // Setting variants to sx property for inline variant resolution
      //@ts-ignore
      sxStyleIds.component.variants = componentStyleIds.variants;
      //@ts-ignore
      sxStyleIds.component.compoundVariants = componentStyleIds.compoundVariants;
      setColorModeBaseStyleIds(sxStyleIds.component, COLOR_MODE);
      setColorModeBaseStyleIdsDescendant(sxStyleIds.descendant, COLOR_MODE);

      // setColorModeBaseStyleIds(sxStyleIds.component, COLOR_MODE);
      // setColorModeBaseStyleIds(sxStyleIds.descendant, COLOR_MODE);
      sxComponentStyleIds.current = sxStyleIds.component;
      sxDescendantStyleIds.current = sxStyleIds.descendant;
      //

      // SX component style
      //@ts-ignore
      const {
        baseStyleCSSIds: sxBaseStyleCSSIds,
        variantStyleCSSIds: sxVariantStyleCSSIds,
        passingProps: sxPassingProps
      } = getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      sxComponentStyleIds.current, variantProps, theme, incomingComponentProps);

      //@ts-ignore
      // applySxStyleCSSIds.current = sxStyleCSSIds;

      //@ts-ignore

      applySxBaseStyleCSSIds.current = sxBaseStyleCSSIds;
      //@ts-ignore

      applySxVariantStyleCSSIds.current = sxVariantStyleCSSIds;
      sxComponentPassingProps.current = sxPassingProps;
      // SX descendants

      //@ts-ignore
      applySxDescendantStyleCSSIdsAndPropsWithKey.current = getMergeDescendantsStyleCSSIdsAndPropsWithKey(sxDescendantStyleIds.current, variantProps, theme, incomingComponentProps);
    }

    // Style ids resolution
    useEffect(() => {
      // for component style
      if (states || COLOR_MODE) {
        const {
          baseStyleCSSIds: mergedBaseStyleCSSIds,
          variantStyleCSSIds: mergedVariantStyleCSSIds,
          passingProps: stateProps
        } = getMergedStateAndColorModeCSSIdsAndProps(
        //@ts-ignore
        componentStyleIds, states, variantProps, COLOR_MODE, theme);
        // setApplyComponentStateStyleIds(mergedStateIds);

        setApplyComponentStateBaseStyleIds(mergedBaseStyleCSSIds);
        setApplyComponentStateVariantStyleIds(mergedVariantStyleCSSIds);
        setComponentStatePassingProps(stateProps);

        // for sx props
        const {
          baseStyleCSSIds: mergedSXBaseStyleCSSIds,
          variantStyleCSSIds: mergedSXVariantStyleCSSIds,
          passingProps: mergedSxStateProps
        } = getMergedStateAndColorModeCSSIdsAndProps(
        //@ts-ignore
        sxComponentStyleIds.current, states, variantProps, COLOR_MODE, theme);
        // setApplyStateSxStyleCSSIds(mergedSxStateIds);
        setApplyStateSxBaseStyleCSSIds(mergedSXBaseStyleCSSIds);
        setApplyStateSxVariantStyleCSSIds(mergedSXVariantStyleCSSIds);
        setSxStatePassingProps(mergedSxStateProps);

        // for descendants
        const mergedDescendantsStyle = {};
        Object.keys(componentDescendantStyleIds).forEach(key => {
          const {
            baseStyleCSSIds: descendantBaseStyleCSSIds,
            variantStyleCSSIds: descendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          } = getMergedStateAndColorModeCSSIdsAndProps(
          //@ts-ignore

          componentDescendantStyleIds[key], states, variantProps, COLOR_MODE, theme);
          mergedDescendantsStyle[key] = {
            baseStyleCSSIds: descendantBaseStyleCSSIds,
            variantStyleCSSIds: descendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          };
        });
        setApplyDescendantStateStyleCSSIdsAndPropsWithKey(mergedDescendantsStyle);

        // for sx descendants
        const mergedSxDescendantsStyle = {};
        Object.keys(sxDescendantStyleIds.current).forEach(key => {
          const {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          } = getMergedStateAndColorModeCSSIdsAndProps(
          //@ts-ignore
          sxDescendantStyleIds.current[key], states, variantProps, COLOR_MODE, theme);
          mergedSxDescendantsStyle[key] = {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          };
        });
        setApplySxDescendantStateStyleCSSIdsAndPropsWithKey(mergedSxDescendantsStyle);
      }

      // if (!mergedComponentProps) {
      //   setMergedComponentProps(themeProps);
      // }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [states, COLOR_MODE]);
    const descendantCSSIds = React.useMemo(() => {
      if (applyDescendantsStyleCSSIdsAndPropsWithKey || applyDescendantStateStyleCSSIdsAndPropsWithKey || applySxDescendantStateStyleCSSIdsAndPropsWithKey || applySxDescendantStyleCSSIdsAndPropsWithKey || contextValue) {
        return mergeArraysInObjects(applyDescendantsStyleCSSIdsAndPropsWithKey, applyDescendantStateStyleCSSIdsAndPropsWithKey, applySxDescendantStyleCSSIdsAndPropsWithKey.current, applySxDescendantStateStyleCSSIdsAndPropsWithKey, contextValue);
      } else {
        return {};
      }
    }, [applyDescendantsStyleCSSIdsAndPropsWithKey, applyDescendantStateStyleCSSIdsAndPropsWithKey, applySxDescendantStateStyleCSSIdsAndPropsWithKey, applySxDescendantStyleCSSIdsAndPropsWithKey, contextValue]);
    const styleCSSIds = useMemo(() => [...applyBaseStyleCSSIds, ...applyAncestorBaseStyleCSSIds, ...applyVariantStyleCSSIds, ...applyAncestorVariantStyleCSSIds, ...applyComponentStateBaseStyleIds, ...applyComponentStateVariantStyleIds, ...applySxVariantStyleCSSIds.current, ...applySxStateBaseStyleCSSIds, ...applySxStateVariantStyleCSSIds, ...applySxBaseStyleCSSIds.current], [applyBaseStyleCSSIds, applyVariantStyleCSSIds, applyComponentStateBaseStyleIds, applyComponentStateVariantStyleIds, applyAncestorBaseStyleCSSIds, applyAncestorVariantStyleCSSIds, applySxStateBaseStyleCSSIds, applySxStateVariantStyleCSSIds]);

    // ----- TODO: Refactor rerendering for Native -----
    let dimensions;
    if (Platform.OS !== 'web') {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars, react-hooks/rules-of-hooks
      dimensions = useWindowDimensions();
    }
    const resolvedStyleProps = generateStylePropsFromCSSIds(utilityAndPassingProps, styleCSSIds, globalStyleMap, CONFIG
    // currentWidth
    );

    // Prepare to be applied style based on specificity
    const finalStyleBasedOnSpecificity = useMemo(() => {
      let tempStyle = [];
      if (passingProps !== null && passingProps !== void 0 && passingProps.style) {
        tempStyle.push(passingProps === null || passingProps === void 0 ? void 0 : passingProps.style);
      }
      if (resolvedStyleProps !== null && resolvedStyleProps !== void 0 && resolvedStyleProps.style) {
        tempStyle.push(resolvedStyleProps === null || resolvedStyleProps === void 0 ? void 0 : resolvedStyleProps.style);
      }
      if (remainingComponentProps !== null && remainingComponentProps !== void 0 && remainingComponentProps.style) {
        tempStyle.push(remainingComponentProps === null || remainingComponentProps === void 0 ? void 0 : remainingComponentProps.style);
      }
      return StyleSheet.flatten(tempStyle);
    }, [passingProps === null || passingProps === void 0 ? void 0 : passingProps.style, resolvedStyleProps === null || resolvedStyleProps === void 0 ? void 0 : resolvedStyleProps.style, remainingComponentProps === null || remainingComponentProps === void 0 ? void 0 : remainingComponentProps.style]);
    const AsComp = as || passingProps.as || undefined;

    // const remainingComponentPropsWithoutVariants = getRemainingProps
    const finalComponentProps = {
      // ...passingProps,
      ...resolvedInlineProps,
      ...resolvedStyleProps,
      ...remainingComponentProps,
      style: finalStyleBasedOnSpecificity,
      ref
    };

    // if (componentStyleConfig.DEBUG === 'MYTEXT') {
    //   console.log(
    //     // finalComponentProps,
    //     passingProps,
    //     componentProps,
    //     'hello world 22'
    //   );
    // }

    const component = !AsComp ? /*#__PURE__*/React.createElement(Component, finalComponentProps, children) : /*#__PURE__*/React.createElement(AsComp, finalComponentProps, children);
    if (componentStyleConfig !== null && componentStyleConfig !== void 0 && componentStyleConfig.descendantStyle && (componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : (_componentStyleConfig = componentStyleConfig.descendantStyle) === null || _componentStyleConfig === void 0 ? void 0 : _componentStyleConfig.length) > 0) {
      return /*#__PURE__*/React.createElement(Context.Provider, {
        value: descendantCSSIds
      }, component);
    }
    return component;
  };
  const StyledComp = /*#__PURE__*/React.forwardRef(NewComp);
  StyledComp.displayName = Component !== null && Component !== void 0 && Component.displayName ? 'Styled' + (Component === null || Component === void 0 ? void 0 : Component.displayName) : 'StyledComponent';
  // @ts-ignore
  // StyledComp.config = componentStyleConfig;
  return StyledComp;
}
export function styled(Component, theme, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS) {
  const sxConvertedObject = convertStyledToStyledVerbosed(theme);
  const StyledComponent = verboseStyled(Component, sxConvertedObject, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS);
  return StyledComponent;
}
//# sourceMappingURL=styled.js.map