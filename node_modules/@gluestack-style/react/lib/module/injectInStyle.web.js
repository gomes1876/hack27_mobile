import { inject, injectGlobalCss, flush } from './utils/css-injector';
export { flush };
function createCssVariables(tokens) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gluestack-';
  let cssVariables = '';
  for (const [key, value] of Object.entries(tokens)) {
    const variableName = `${prefix}${key}`;
    if (typeof value === 'object') {
      cssVariables += createCssVariables(value, `${variableName}-`);
    } else {
      cssVariables += `--${variableName}: ${value};\n`;
    }
  }
  return cssVariables;
}
export function injectGlobalCssStyle(css) {
  let styleTagId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css-injected-global';
  injectGlobalCss(css, styleTagId);
}
export function injectCssVariablesGlobalStyle(componentExtendedConfig) {
  injectGlobalCss(`:root {${createCssVariables(componentExtendedConfig.tokens)}\n};`);
}
export function injectInStyle(_globalStyleMap, orderedSXResolved, type, styleTagId) {
  let toBeInjectedCssRules = '';
  orderedSXResolved.forEach(styleResolved => {
    toBeInjectedCssRules += styleResolved.meta.cssRuleset;
  });

  // console.log(orderedSXResolved, toBeInjectedCssRules, "hello ordered resolved")

  if (toBeInjectedCssRules) {
    inject(`@media screen {${toBeInjectedCssRules}}`, type, styleTagId);

    // if (typeof window !== 'undefined') {
    //   const styleTag = document.getElementById(styleTagId);

    //   if (!styleTag) {
    //     inject(`@media screen {${toBeInjectedCssRules}}`, type, styleTagId);
    //   }
    // }
  }
}
//# sourceMappingURL=injectInStyle.web.js.map