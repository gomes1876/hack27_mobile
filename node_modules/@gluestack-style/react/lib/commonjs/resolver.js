"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SXResolvedToOrderedSXResolved = SXResolvedToOrderedSXResolved;
exports.StyledValueToCSSObject = StyledValueToCSSObject;
exports.checkAndPush = checkAndPush;
exports.getComponentResolved = getComponentResolved;
exports.getComponentResolvedBaseStyle = getComponentResolvedBaseStyle;
exports.getComponentResolvedVariantStyle = getComponentResolvedVariantStyle;
exports.getComponentStyleIds = getComponentStyleIds;
exports.getDescendantResolved = getDescendantResolved;
exports.getDescendantResolvedBaseStyle = getDescendantResolvedBaseStyle;
exports.getDescendantResolvedVariantStyle = getDescendantResolvedVariantStyle;
exports.getDescendantStyleIds = getDescendantStyleIds;
exports.getStyleIds = getStyleIds;
exports.styledResolvedToOrderedSXResolved = styledResolvedToOrderedSXResolved;
exports.styledToStyledResolved = styledToStyledResolved;
exports.sxToSXResolved = sxToSXResolved;
var _utils = require("./utils");
// import { isWeb } from './isWeb';

function getWeightBaseOnPath(path) {
  const weightObject = {
    styled: [],
    sx: [],
    state: []
  };
  const STYLED_PRECENDENCE = {
    baseStyle: 1,
    variants: 2,
    compoundVariants: 3
  };
  const SX_PRECEDENCE = {
    style: 1,
    platform: 2,
    colorMode: 3,
    queries: 4,
    state: 5,
    descendants: 6
  };
  const STATE_PRECENDENCE = {
    indeterminate: 1,
    checked: 1,
    readOnly: 1,
    required: 2,
    invalid: 2,
    focus: 3,
    focusVisible: 4,
    hover: 5,
    pressed: 6,
    active: 6,
    loading: 7,
    disabled: 10
  };
  const tempPath = [...path];
  for (let i = 0; i < tempPath.length; i++) {
    const currentValue = tempPath[i];
    let stateType = '';
    switch (currentValue) {
      case 'queries':
        i = i + 2;
        break;
      case 'state':
        stateType = tempPath[i + 1];
        i = i + 1;
        break;
      case 'descendants':
        break;
      default:
    }
    if (STYLED_PRECENDENCE[currentValue]) {
      weightObject.styled.push(STYLED_PRECENDENCE[currentValue]);
    }
    if (SX_PRECEDENCE[currentValue]) {
      weightObject.sx.push(SX_PRECEDENCE[currentValue]);
    }
    if (currentValue === 'state' && STATE_PRECENDENCE[stateType]) {
      weightObject.state.push(STATE_PRECENDENCE[stateType]);
    }
  }
  const weightObjectStyledValue = weightObject.styled.reduce((partialSum, a) => partialSum + a, 0);
  const weightObjectSxValue = weightObject.sx.reduce((partialSum, a) => partialSum + a, 0);
  const weightObjectStateValue = weightObject.state.reduce((partialSum, a) => partialSum + a, 0);

  // console.log(tempPath, weightObject, 'temp path here');

  let weightedStyleString = '';
  if (weightObjectStyledValue < 10) {
    weightedStyleString = '0' + weightObjectStyledValue;
  } else {
    weightedStyleString = '' + weightObjectStyledValue;
  }
  let weightedSxString = '';
  if (weightObjectSxValue < 10) {
    weightedSxString = '0' + weightObjectSxValue;
  } else {
    weightedSxString = '' + weightObjectSxValue;
  }
  let weightedStateString = '';
  if (weightObjectStateValue < 10) {
    weightedStateString = '0' + weightObjectStateValue;
  } else {
    weightedStateString = '' + weightObjectStateValue;
  }
  const weight = parseInt(weightedStateString + weightedStyleString + weightedSxString, 10);
  return weight;
}
function checkAndPush(item, ret, keyToCheck) {
  function getIndexes(array, str) {
    return array.map((item, index) => item === str ? index : -1).filter(i => i !== -1);
  }
  function createNestedObject(arr) {
    let obj = {};
    arr.reduce((acc, curr) => {
      return acc[curr] = {};
    }, obj);
    return obj;
  }
  function setNestedObjectValue(obj, keyPath, value) {
    // If the key path is empty, return the value
    if (keyPath.length === 0) return value;

    // Otherwise, set the value at the current key path and recurse
    const key = keyPath[0];
    obj[key] = obj[key] || {};
    obj[key] = setNestedObjectValue(obj[key], keyPath.slice(1), value);
    return obj;
  }
  // keyToCheck = "baseStyle" | "variants" | "sizes"
  if (item.meta.path.includes(keyToCheck)) {
    // if (!item.meta.path.includes('state')) {
    //   if (!ret.ids) {
    //     ret.ids = [];
    //   }
    //   ret.ids.push(item.meta.cssId);
    //   ret.props = item?.meta?.props;
    // } else
    if (!item.meta.path.includes('state') && !item.meta.path.includes('colorMode')) {
      var _item$meta;
      if (!ret.ids) {
        ret.ids = [];
      }
      ret.ids.push(item.meta.cssId);
      ret.props = item === null || item === void 0 ? void 0 : (_item$meta = item.meta) === null || _item$meta === void 0 ? void 0 : _item$meta.props;

      // ret.default.push(item.meta.cssId);
    } else if (item.meta.path.includes('state') || item.meta.path.includes('colorMode')) {
      var _item$meta2;
      const allStates = getIndexes(item.meta.path, 'state');
      const allColorModes = getIndexes(item.meta.path, 'colorMode');

      // const allStatesAndColorMode = [...allStates, ...allColorModes];

      const mergeAllStateKey = [];
      allStates.forEach(statePath => {
        const state = item.meta.path[statePath + 1];
        mergeAllStateKey.push('state');
        mergeAllStateKey.push(state);
      });
      allColorModes.forEach(colorModePath => {
        const colorMode = item.meta.path[colorModePath + 1];
        mergeAllStateKey.push('colorMode');
        mergeAllStateKey.push(colorMode);
      });
      const stateObject = createNestedObject(mergeAllStateKey);
      setNestedObjectValue(stateObject, mergeAllStateKey, {
        ids: [item.meta.cssId],
        props: item === null || item === void 0 ? void 0 : (_item$meta2 = item.meta) === null || _item$meta2 === void 0 ? void 0 : _item$meta2.props
      });
      (0, _utils.deepMergeArray)(ret, stateObject);
    }
  }
}
function getComponentResolved(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path;
    return !((_item$meta$path = item.meta.path) !== null && _item$meta$path !== void 0 && _item$meta$path.includes('descendants'));
  });
}
function getDescendantResolved(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path2;
    return (_item$meta$path2 = item.meta.path) === null || _item$meta$path2 === void 0 ? void 0 : _item$meta$path2.includes('descendants');
  });
}
function getComponentResolvedBaseStyle(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path3, _item$meta$path4, _item$meta$path5;
    return !((_item$meta$path3 = item.meta.path) !== null && _item$meta$path3 !== void 0 && _item$meta$path3.includes('descendants')) && !((_item$meta$path4 = item.meta.path) !== null && _item$meta$path4 !== void 0 && _item$meta$path4.includes('variants') || (_item$meta$path5 = item.meta.path) !== null && _item$meta$path5 !== void 0 && _item$meta$path5.includes('compoundVariants'));
  });
}
function getComponentResolvedVariantStyle(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path6, _item$meta$path7, _item$meta$path8;
    return !((_item$meta$path6 = item.meta.path) !== null && _item$meta$path6 !== void 0 && _item$meta$path6.includes('descendants')) && (((_item$meta$path7 = item.meta.path) === null || _item$meta$path7 === void 0 ? void 0 : _item$meta$path7.includes('variants')) || ((_item$meta$path8 = item.meta.path) === null || _item$meta$path8 === void 0 ? void 0 : _item$meta$path8.includes('compoundVariants')));
  });
}
function getDescendantResolvedBaseStyle(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path9, _item$meta$path10, _item$meta$path11;
    return ((_item$meta$path9 = item.meta.path) === null || _item$meta$path9 === void 0 ? void 0 : _item$meta$path9.includes('descendants')) && !((_item$meta$path10 = item.meta.path) !== null && _item$meta$path10 !== void 0 && _item$meta$path10.includes('variants') || (_item$meta$path11 = item.meta.path) !== null && _item$meta$path11 !== void 0 && _item$meta$path11.includes('compoundVariants'));
  });
}
function getDescendantResolvedVariantStyle(orderedResolved) {
  return orderedResolved.filter(item => {
    var _item$meta$path12, _item$meta$path13, _item$meta$path14;
    return ((_item$meta$path12 = item.meta.path) === null || _item$meta$path12 === void 0 ? void 0 : _item$meta$path12.includes('descendants')) && (((_item$meta$path13 = item.meta.path) === null || _item$meta$path13 === void 0 ? void 0 : _item$meta$path13.includes('variants')) || ((_item$meta$path14 = item.meta.path) === null || _item$meta$path14 === void 0 ? void 0 : _item$meta$path14.includes('compoundVariants')));
  });
}
function getComponentStyleIds(arr) {
  const ret = {
    baseStyle: {},
    variants: {},
    compoundVariants: []
    // sizes: {},
  };

  for (let i in arr) {
    var _item$meta3, _item$meta3$path, _item$meta4, _item$meta4$path;
    const item = arr[i];
    checkAndPush(item, ret.baseStyle, 'baseStyle');
    let variantType = '';
    let variantName = '';
    if (item !== null && item !== void 0 && (_item$meta3 = item.meta) !== null && _item$meta3 !== void 0 && (_item$meta3$path = _item$meta3.path) !== null && _item$meta3$path !== void 0 && _item$meta3$path.includes('variants')) {
      variantType = item.meta.path[item.meta.path.indexOf('variants') + 1];
      variantName = item.meta.path[item.meta.path.indexOf('variants') + 2];
      if (!ret.variants[variantType]) {
        ret.variants[variantType] = {
          [variantName]: {
            ids: []
          }
        };
      } else if (ret.variants[variantType] && !ret.variants[variantType][variantName]) {
        ret.variants[variantType][variantName] = {
          ids: []
        };
      }
      checkAndPush(item, ret.variants[variantType][variantName], 'variants');
      // console.log('styleids>>Var', ret);
    }

    // if (item?.meta?.path?.includes('variants')) {
    //   variantType = item.meta.path[item.meta.path.indexOf('variants') + 1];
    //   variantName = item.meta.path[item.meta.path.indexOf('variants') + 2];

    //   if (!ret.variants[variantType]) {
    //     ret.variants[variantType] = { [variantName]: { ids: [] } };
    //   } else if (
    //     ret.variants[variantType] &&
    //     !ret.variants[variantType][[variantName]]
    //   ) {
    //     ret.variants[variantType][variantName] = { ids: [] };
    //   }

    //   checkAndPush(item, ret.variants[variantType][variantName], 'variants');
    // }

    if (item !== null && item !== void 0 && (_item$meta4 = item.meta) !== null && _item$meta4 !== void 0 && (_item$meta4$path = _item$meta4.path) !== null && _item$meta4$path !== void 0 && _item$meta4$path.includes('compoundVariants')) {
      var _item$meta5;
      // let conditionStartIndex = item.meta.path.indexOf('compoundVariants');
      // let condition = {} as any;

      // for (let i = conditionStartIndex + 1; i < item.meta.path.length; i++) {
      //   if ((i - conditionStartIndex) % 2 !== 0) {
      //     condition[item.meta.path[i]] = item.meta.path[i + 1];
      //     i++;
      //   }
      // }

      // console.log(condition, item.meta, 'hello world');
      // console.log('styleids>>', ret.compoundVariants);

      // if (ret.compoundVariants.length === 0)
      //   ret.compoundVariants = [{ ids: [], n: 'alsjnf' }];

      const condition = item === null || item === void 0 ? void 0 : (_item$meta5 = item.meta) === null || _item$meta5 === void 0 ? void 0 : _item$meta5.condition;
      let conditionIndex = ret.compoundVariants.findIndex(item => item.condition === condition);
      // if (
      //   ret.compoundVariants.findIndex((item) => item.condition === condition) >
      //   -1
      // ) {
      // }

      if (conditionIndex === -1) {
        var _item$meta6;
        ret.compoundVariants.push({
          condition: item === null || item === void 0 ? void 0 : (_item$meta6 = item.meta) === null || _item$meta6 === void 0 ? void 0 : _item$meta6.condition
        });
        conditionIndex = ret.compoundVariants.length - 1;
      }
      // console.log('>>>><<<<<', conditionIndex);

      checkAndPush(item, ret.compoundVariants[conditionIndex], 'compoundVariants');

      // checkAndPush(item, ret.compoundVariants, 'compoundVariants');
      // console.log('styleids>>', ret.compoundVariants);
    }
  }

  return ret;
}
function getDescendantStyleIds(arr) {
  let descendantStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const ret = {};
  // return ret;
  descendantStyle.forEach(style => {
    const filteredOrderListByDescendant = arr.filter(item => item.meta.path[item.meta.path.lastIndexOf('descendants') + 1] === style);
    ret[style] = getComponentStyleIds(filteredOrderListByDescendant);
  });
  return ret;
}
function sxToSXResolved(sx) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let meta = arguments.length > 2 ? arguments[2] : undefined;
  let CONFIG = arguments.length > 3 ? arguments[3] : undefined;
  const resolvedCSSStyle = StyledValueToCSSObject(sx === null || sx === void 0 ? void 0 : sx.style, CONFIG);

  // console.log('hello here ***', sx?.style, resolvedCSSStyle);
  const styledValueResolvedWithMeta = {
    original: (sx === null || sx === void 0 ? void 0 : sx.style) ?? {},
    resolved: resolvedCSSStyle,
    meta: {
      ...meta,
      path,
      weight: getWeightBaseOnPath([...path, 'style']),
      // @ts-ignore
      props: sx === null || sx === void 0 ? void 0 : sx.props
      // cssId: ,
      // cssRuleset: ,
    }
  };

  // console.log('sx !@#!@#!@#!@#', sx);
  // console.log(sx, '********');
  const ret = {
    //@ts-ignore
    styledValueResolvedWithMeta: styledValueResolvedWithMeta,
    //@ts-ignore
    queriesResolved: sx !== null && sx !== void 0 && sx.queries ? sx.queries.map((query, index) => {
      const resolvedCondition = (0, _utils.resolveTokensFromConfig)(CONFIG, {
        condition: query.condition
      }).condition;
      const sxResolvedValue = sxToSXResolved(query.value, [...path, 'queries', index, query.condition], {
        queryCondition: resolvedCondition
      }, CONFIG);
      if (sxResolvedValue !== null && sxResolvedValue !== void 0 && sxResolvedValue.styledValueResolvedWithMeta) {
        sxResolvedValue.styledValueResolvedWithMeta.meta.queryCondition = resolvedCondition;
      }
      return {
        original: {
          condition: query.condition,
          value: query.value
        },
        resolved: {
          condition: resolvedCondition,
          value: {
            ...sxResolvedValue
          }
        }
      };
    }) : undefined,
    platform: sx !== null && sx !== void 0 && sx.platform ? Object.keys(sx.platform).reduce((acc, key) => ({
      ...acc,
      [key]: sxToSXResolved(
      //@ts-ignore
      sx.platform[key], [...path, 'platform', key], meta, CONFIG)
    }), {}) : undefined,
    colorMode: sx !== null && sx !== void 0 && sx.colorMode ? Object.keys(sx.colorMode).reduce((acc, key) => {
      const sxResolved = sxToSXResolved(
      //@ts-ignore
      sx.colorMode[key], [...path, 'colorMode', key], {
        colorMode: key,
        ...meta
      }, CONFIG);
      if (sxResolved !== null && sxResolved !== void 0 && sxResolved.styledValueResolvedWithMeta) {
        sxResolved.styledValueResolvedWithMeta.meta.colorMode = key;
      }
      return {
        ...acc,
        [key]: sxResolved
      };
    }, {}) : undefined,
    state: sx !== null && sx !== void 0 && sx.state ? Object.keys(sx.state).reduce((acc, key) => ({
      ...acc,
      [key]: sxToSXResolved(
      //@ts-ignore
      sx.state[key], [...path, 'state', key], meta, CONFIG)
    }), {}) : undefined,
    descendants: sx !== null && sx !== void 0 && sx.descendants ? Object.keys(sx.descendants).reduce((acc, key) => ({
      ...acc,
      [key]: sxToSXResolved(
      //@ts-ignore
      sx.descendants[key], [...path, 'descendants', key], meta, CONFIG)
    }), {}) : undefined
  };

  // CSS computation based on Meta data
  // const { cssId, cssRuleset } = getCSSIdAndRuleset(
  //   ret.styledValueResolvedWithMeta,
  //   path
  // );

  // if(ret.queriesResolved) {
  //   // access the ret.queriesResolved[i].resolved.condition
  // }

  // console.log(ret.queriesResolved, 'ret ****');
  // console.log(ret.colorMode, 'colorMode ret ****');
  // ret.styledValueResolvedWithMeta.meta.cssId = cssId;
  // ret.styledValueResolvedWithMeta.meta.cssRuleset = cssRuleset;

  return ret;
}
function StyledValueToCSSObject(input, CONFIG) {
  if (!input) {
    return {};
  }
  // return input;
  return (0, _utils.resolvedTokenization)(input, CONFIG);
}
function SXResolvedToOrderedSXResolved(sxResolved) {
  var _sxResolved$styledVal;
  let orderedSXResolved = [];
  if (sxResolved !== null && sxResolved !== void 0 && (_sxResolved$styledVal = sxResolved.styledValueResolvedWithMeta) !== null && _sxResolved$styledVal !== void 0 && _sxResolved$styledVal.original) {
    orderedSXResolved = [sxResolved.styledValueResolvedWithMeta];
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.platform) {
    Object.keys(sxResolved.platform).forEach(key => {
      //@ts-ignore
      const platformSXResolved = sxResolved === null || sxResolved === void 0 ? void 0 : sxResolved.platform[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(platformSXResolved));
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.colorMode) {
    Object.keys(sxResolved.colorMode).forEach(key => {
      //@ts-ignore
      const colorModeSXResolved = sxResolved.colorMode[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(colorModeSXResolved));
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.queriesResolved) {
    sxResolved.queriesResolved.forEach(queryResolved => {
      orderedSXResolved.push(
      //@ts-ignore

      ...SXResolvedToOrderedSXResolved(queryResolved.resolved.value));
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.state) {
    Object.keys(sxResolved.state).forEach(key => {
      //@ts-ignore
      const stateSXResolved = sxResolved.state[key];
      // stateSXResolved.styledValueResolvedWithMeta.meta.weight =
      //   SX_STYLE_PRECEDENCE.state + (STATE_PRECENDENCE[key] || 0) / 100;
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(stateSXResolved));
      // orderedSXResolved.push(stateSXResolved.styledValueResolvedWithMeta);
    });
  }

  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.descendants) {
    Object.keys(sxResolved.descendants).forEach(key => {
      //@ts-ignore
      const descendantSXResolved = sxResolved.descendants[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(descendantSXResolved));
    });
  }
  return orderedSXResolved.sort((a, b) => a.meta.weight - b.meta.weight);
}
function reduceAndResolveCompoundVariants(compoundVariants, path, CONFIG) {
  const compoundVariantsResolved = compoundVariants === null || compoundVariants === void 0 ? void 0 : compoundVariants.map((compoundVariant, index) => {
    const {
      value,
      ...condition
    } = compoundVariant;
    // let conditionPath: Array<string> = [];
    // Object.keys(condition).map((key) => {
    //   conditionPath.push(key);
    //   conditionPath.push(condition[key]);
    // });
    return sxToSXResolved(
    //@ts-ignore

    value, [...path, 'compoundVariants', index], {
      condition
    }, CONFIG);
  });
  // console.log(compoundVariantsResolved, 'compoundVariantsResolved');

  return compoundVariantsResolved;
}
function styledToStyledResolved(styled) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let CONFIG = arguments.length > 2 ? arguments[2] : undefined;
  // console.log(
  //   'styled.compoundVariants',
  //   reduceAndResolveCompoundVariants(styled.compoundVariants, path, CONFIG)
  // );

  return {
    baseStyle: styled !== null && styled !== void 0 && styled.baseStyle ?
    //@ts-ignore
    sxToSXResolved(styled.baseStyle, [...path, 'baseStyle'], {}, CONFIG) : undefined,
    variants: styled !== null && styled !== void 0 && styled.variants ? Object.keys(styled.variants).reduce((acc, key1) => {
      var _styled$variants;
      return {
        ...acc,
        // @ts-ignore
        [key1]: Object.keys(styled === null || styled === void 0 ? void 0 : (_styled$variants = styled.variants) === null || _styled$variants === void 0 ? void 0 : _styled$variants[key1]).reduce((acc, key) => ({
          ...acc,
          [key]: sxToSXResolved(
          //@ts-ignore
          styled.variants[key1][key], [...path, 'variants', key1, key], {}, CONFIG)
        }), {})

        // sxToSXResolved(
        //   //@ts-ignore
        //   styled.variants[key],
        //   [...path, 'variants', key],
        //   {},
        //   CONFIG
        // ),
      };
    }, {}) : undefined,
    // @ts-ignore
    compoundVariants: styled !== null && styled !== void 0 && styled.compoundVariants ?
    // @ts-ignore
    reduceAndResolveCompoundVariants(styled.compoundVariants, path, CONFIG) : undefined
  };
}
function styledResolvedToOrderedSXResolved(styledResolved) {
  const orderedSXResolved = [
  //@ts-ignore
  ...SXResolvedToOrderedSXResolved(styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.baseStyle)];
  if (styledResolved.variants) {
    Object.keys(styledResolved.variants).forEach(key => {
      //@ts-ignore
      const variantSXResolved = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.variants[key];
      // variantSXResolved.styledValueResolvedWithMeta.meta.weight =
      //   STYLED_PRECENDENCE.variants;
      Object.keys(variantSXResolved).forEach(variantKey => {
        // @ts-ignore
        const variantValueSXResolved = variantSXResolved[variantKey];
        orderedSXResolved.push(...SXResolvedToOrderedSXResolved(variantValueSXResolved));
      });
    });
  }
  if (styledResolved.compoundVariants) {
    styledResolved.compoundVariants.forEach(compoundVariant => {
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(compoundVariant));
    });
  }
  return orderedSXResolved.sort((a, b) => a.meta.weight - b.meta.weight);
}
function getStyleIds(orderedResolved, componentStyleConfig) {
  const componentOrderResolved = getComponentResolved(orderedResolved);
  const descendantOrderResolved = getDescendantResolved(orderedResolved);
  const component = getComponentStyleIds(componentOrderResolved);
  const descendant = getDescendantStyleIds(descendantOrderResolved, componentStyleConfig.descendantStyle);
  return {
    component,
    descendant
  };
}
//# sourceMappingURL=resolver.js.map