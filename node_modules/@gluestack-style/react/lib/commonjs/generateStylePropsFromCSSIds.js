"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateStylePropsFromCSSIds = generateStylePropsFromCSSIds;
exports.getClosestBreakpoint = getClosestBreakpoint;
exports.getClosestBreakpointValue = getClosestBreakpointValue;
var _reactNative = require("react-native");
function getClosestBreakpoint(values, point) {
  const dimValues = Object.values(values);
  let index = -1;
  let breakpointsObj = {};
  for (let i = 0; i < dimValues.length; i++) {
    breakpointsObj[dimValues[i]] = i;
  }
  const breakpoints = Object.keys(breakpointsObj);
  for (let i = 0; i < breakpoints.length; i++) {
    if (parseInt(breakpoints[i]) === point) {
      index = breakpointsObj[breakpoints[i]];
      break;
    } else if (parseInt(breakpoints[i]) > point && i !== 0) {
      index = breakpointsObj[breakpoints[i - 1]];
      break;
    }
    // If windowWidth is greater than last available breakpoint clamp it to last index
    else if (parseInt(breakpoints[i]) < point && i === dimValues.length - 1) {
      index = breakpointsObj[breakpoints[i]];
      break;
    }
  }
  return breakpoints[index];
}
function getMinWidthFromMediaQuery(mediaQuery) {
  const regex = /\(\s*min-width:\s*(\d+)px\s*\)/;
  const matches = regex.exec(mediaQuery);
  if (matches) {
    return parseInt(matches[1], 10);
  }
  return 0;
}
function getClosestBreakpointValue(mediaQueries, value) {
  if (!mediaQueries) return;
  const dimValues = Object.values(mediaQueries);
  let index = -1;
  let breakpointsObj = {};
  for (let i = 0; i < dimValues.length; i++) {
    const minWidth = getMinWidthFromMediaQuery(dimValues[i]);
    breakpointsObj[minWidth] = dimValues[i];
  }
  const breakpoints = Object.keys(breakpointsObj);
  for (let i = 0; i < breakpoints.length; i++) {
    if (parseInt(breakpoints[i]) === value) {
      index = breakpoints[i];
      break;
    } else if (parseInt(breakpoints[i]) > value && i !== 0) {
      index = breakpoints[i - 1];
      break;
    }
    // If windowWidth is greater than last available breakpoint clamp it to last index
    else if (parseInt(breakpoints[i]) < value && i === dimValues.length - 1) {
      index = breakpoints[i];
      break;
    }
  }
  return index;
}
function getWidthFromMediaQuery(condition) {
  var match = condition.match(/\(min-width:\s*(\d+)px\)/);
  if (match) {
    return parseInt(match[1]);
  } else {
    return null;
  }
}
function isValidBreakpoint(config, queryCondition) {
  var _Dimensions$get;
  const windowWidth = (_Dimensions$get = _reactNative.Dimensions.get('window')) === null || _Dimensions$get === void 0 ? void 0 : _Dimensions$get.width;
  const currentBreakpointValue = getClosestBreakpointValue(config.tokens.mediaQueries, windowWidth);
  if (getWidthFromMediaQuery(queryCondition) !== null &&
  // @ts-ignore
  getWidthFromMediaQuery(queryCondition) <= currentBreakpointValue) {
    return true;
  }
  return false;
}
function generateStylePropsFromCSSIds(props, styleCSSIds, globalStyleMap, config) {
  var _props$dataSet, _props$dataSet2;
  // for RN
  const styleObj = [];
  let styleCSSIdsString = '';
  if (_reactNative.Platform.OS !== 'web') {
    styleCSSIds.forEach(cssId => {
      if (globalStyleMap.get(cssId)) {
        // check for queryCondtion
        if (globalStyleMap.get(cssId).meta.queryCondition) {
          if (isValidBreakpoint(config, globalStyleMap.get(cssId).meta.queryCondition)) {
            styleObj.push(globalStyleMap.get(cssId).resolved);
          }
        } else {
          styleObj.push(globalStyleMap.get(cssId).resolved);
        }
        //
      }
    });
  } else {
    styleCSSIdsString = styleCSSIds.join(' ');
  }
  return {
    'dataSet': {
      ...props.dataSet,
      style: props !== null && props !== void 0 && (_props$dataSet = props.dataSet) !== null && _props$dataSet !== void 0 && _props$dataSet.style ? props.dataSet.style + ' ' + styleCSSIdsString : styleCSSIdsString
    },
    'data-style': props !== null && props !== void 0 && (_props$dataSet2 = props.dataSet) !== null && _props$dataSet2 !== void 0 && _props$dataSet2.style ? props.dataSet.style + ' ' + styleCSSIdsString : styleCSSIdsString,
    'style': props.style ? [...styleObj, props.style] : styleObj
  };
}
//# sourceMappingURL=generateStylePropsFromCSSIds.js.map