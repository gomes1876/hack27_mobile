"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "flush", {
  enumerable: true,
  get: function () {
    return _cssInjector.flush;
  }
});
exports.injectCssVariablesGlobalStyle = injectCssVariablesGlobalStyle;
exports.injectGlobalCssStyle = injectGlobalCssStyle;
exports.injectInStyle = injectInStyle;
var _cssInjector = require("./utils/css-injector");
function createCssVariables(tokens) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gluestack-';
  let cssVariables = '';
  for (const [key, value] of Object.entries(tokens)) {
    const variableName = `${prefix}${key}`;
    if (typeof value === 'object') {
      cssVariables += createCssVariables(value, `${variableName}-`);
    } else {
      cssVariables += `--${variableName}: ${value};\n`;
    }
  }
  return cssVariables;
}
function injectGlobalCssStyle(css) {
  let styleTagId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css-injected-global';
  (0, _cssInjector.injectGlobalCss)(css, styleTagId);
}
function injectCssVariablesGlobalStyle(componentExtendedConfig) {
  (0, _cssInjector.injectGlobalCss)(`:root {${createCssVariables(componentExtendedConfig.tokens)}\n};`);
}
function injectInStyle(_globalStyleMap, orderedSXResolved, type, styleTagId) {
  let toBeInjectedCssRules = '';
  orderedSXResolved.forEach(styleResolved => {
    toBeInjectedCssRules += styleResolved.meta.cssRuleset;
  });

  // console.log(orderedSXResolved, toBeInjectedCssRules, "hello ordered resolved")

  if (toBeInjectedCssRules) {
    (0, _cssInjector.inject)(`@media screen {${toBeInjectedCssRules}}`, type, styleTagId);

    // if (typeof window !== 'undefined') {
    //   const styleTag = document.getElementById(styleTagId);

    //   if (!styleTag) {
    //     inject(`@media screen {${toBeInjectedCssRules}}`, type, styleTagId);
    //   }
    // }
  }
}
//# sourceMappingURL=injectInStyle.web.js.map