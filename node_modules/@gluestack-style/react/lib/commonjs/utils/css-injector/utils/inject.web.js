"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.injectGlobalCss = exports.injectCss = exports.flush = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const toBeFlushedStyles = {
  'global': {},
  'boot-base': {},
  'boot-descendant-base': {},
  'boot-variant': {},
  'boot-descendant-variant': {},
  'passing-base': {},
  'inline-base': {},
  'inline-variant': {},
  'inline-descendant-base': {}
};
const order = ['global', 'boot-base', 'boot-descendant-base', 'boot-variant', 'boot-descendant-variant', 'inline-descendant-base', 'passing-base', 'inline-variant', 'inline-base'];
if (typeof window !== 'undefined') {
  //TODO: remvoe platform dependency
  // Test on all the platforms
  if (_reactNative.Platform.OS === 'web') {
    order.forEach(orderKey => {
      let wrapperElement = document.getElementById(orderKey);
      if (!wrapperElement) {
        wrapperElement = document.createElement('div');
        wrapperElement.id = orderKey;
        document.head.appendChild(wrapperElement);
      }
    });
  }
}
const createStyle = (styleTagId, css) => {
  //
  let style = document.createElement('style');
  style.id = styleTagId;
  style.appendChild(document.createTextNode(''));
  style.innerHTML = css;
  return style;
};
const injectCss = (css, wrapperType, styleTagId) => {
  // let modifiedStylesheet = {} as any;

  if (!toBeFlushedStyles[wrapperType]) {
    toBeFlushedStyles[wrapperType] = {};
  }
  if (toBeFlushedStyles[wrapperType][styleTagId]) {
    // toBeFlushedStyles[wrapperType][styleTagId].push(css);
  } else {
    toBeFlushedStyles[wrapperType][styleTagId] = [css];
  }
  if (typeof window !== 'undefined') {
    let wrapperElement = document.querySelector('#' + wrapperType);
    if (wrapperElement) {
      let style = wrapperElement.querySelector(`[id='${styleTagId}']`);
      if (!style) {
        style = createStyle(styleTagId, css);
        wrapperElement.insertBefore(style, wrapperElement.firstChild);
        // wrapperElement.appendChild(style);
      }
    }
  }

  // if (modifiedStylesheet && modifiedStylesheet.insertRule) {
  //   modifiedStylesheet.insertRule(css);
  // }
};
exports.injectCss = injectCss;
const injectGlobalCss = function (css) {
  let styleTagID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css-injected-global';
  injectCss(css, 'global', styleTagID);
};
exports.injectGlobalCss = injectGlobalCss;
const flush = () => {
  let toBeFlushedStylesGlobal = [];
  order.forEach(orderKey => {
    const styleChildren = [];
    Object.keys(toBeFlushedStyles[orderKey]).forEach(styleTagId => {
      let rules = toBeFlushedStyles[orderKey][styleTagId];
      styleChildren.unshift( /*#__PURE__*/_react.default.createElement('style', {
        id: styleTagId,
        key: styleTagId,
        dangerouslySetInnerHTML: {
          __html: rules.join('\n')
        }
      }));
    });
    toBeFlushedStylesGlobal.push( /*#__PURE__*/_react.default.createElement('div', {
      id: orderKey,
      key: orderKey
    }, styleChildren));
  });
  // Object.keys(toBeFlushedStyles).map(() => {

  // })

  // Object.keys(toBeFlushedStyles['boot']).map((styleTagId) => {
  //   let rules = toBeFlushedStyles['boot'][styleTagId];
  //   toBeFlushedStylesGlobal.push(
  //     React.createElement('style', {
  //       id: styleTagId,
  //       key: styleTagId,
  //       dangerouslySetInnerHTML: {
  //         __html: rules.join('\n'),
  //       },
  //     })
  //   );
  // });
  // Object.keys(toBeFlushedStyles['inline']).map((styleTagId) => {
  //   let rules = toBeFlushedStyles['inline'[styleTagId];
  //   toBeFlushedStylesGlobal.push(
  //     React.createElement('style', {
  //       id: styleTagId,
  //       key: styleTagId,
  //       dangerouslySetInnerHTML: {
  //         __html: rules.join('\n'),
  //       },
  //     })
  //   );
  // });

  return toBeFlushedStylesGlobal;
};
exports.flush = flush;
//# sourceMappingURL=inject.web.js.map